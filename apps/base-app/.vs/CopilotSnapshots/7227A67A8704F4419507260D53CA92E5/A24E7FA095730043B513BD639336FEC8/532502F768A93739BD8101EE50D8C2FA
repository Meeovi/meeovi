import { createMagentoClient } from '../clients/magentoClient'
import type { CommerceProvider, CommerceProduct, CommerceListParams } from '../types'
import type { ProviderContext } from './base'

import {
  ProductsDocument,
  type ProductsQuery,
  type ProductsQueryVariables,
} from '../generated/magento/graphql'

import { normalizeWithMapping } from '../normalization/engine'
import { magentoToDirectusProductMapping } from '../normalization/product.map'

type MagentoProduct = NonNullable<NonNullable<ProductsQuery['products']>['items']>[number]

/**
 * Pre-shape Magento product into a simpler intermediate object that
 * matches what the mapping expects (`brands`, `currencies`, etc.).
 */
const prepareMagentoProduct = (p: MagentoProduct): Record<string, unknown> => {
  if (!p) return { brands: [], currencies: [], price: 0 }

  // Prefer explicit special price, then price_range (if available), otherwise 0
  const pRec = p as unknown as Record<string, unknown>
  const sp = pRec['special_price']
  const specialPrice = typeof sp === 'number' ? sp : undefined
  const priceRangeRec = pRec['price_range'] as Record<string, unknown> | undefined
  const minimumPrice = priceRangeRec?.['minimum_price'] as Record<string, unknown> | undefined
  const priceRange = minimumPrice?.['regular_price'] as { value?: number, currency?: string } | undefined

  const price = specialPrice ?? priceRange?.value ?? 0

  // Magento items returned by the lightweight `products` query don't include
  // rich brand/currency info by default. Keep brands/currencies empty unless
  // those fields are present on the product object.
  const cb = pRec['custom_brand']
  const brands = cb && typeof cb === 'object'
    ? [
        {
          name: ((cb as Record<string, unknown>).name as string) ?? '',
          slug: ((cb as Record<string, unknown>).url_key as string) ?? '',
        },
      ]
    : []

  const currencies = priceRange
    ? [
        {
          symbol: priceRange.currency ?? '',
        },
      ]
    : []

  return {
    ...(p as unknown as Record<string, unknown>),
    price,
    brands,
    currencies,
  }
}

export const mapMagentoProduct = (p: MagentoProduct): CommerceProduct => {
  if (!p) throw new Error('Product is null')

  const prepared = prepareMagentoProduct(p)
  const normalized = normalizeWithMapping<CommerceProduct>(
    magentoToDirectusProductMapping,
    prepared,
  )

  // Ensure id fallback to sku
  if (!normalized.id) {
    const sku = (p as unknown as Record<string, unknown>)['sku']
    normalized.id = typeof sku === 'string' ? sku : ''
  }

  return normalized
}

export const createMagentoProvider = (ctx: ProviderContext): CommerceProvider => {
  const cfg = ctx as Record<string, unknown>
  const endpoint = typeof cfg['magentoEndpoint'] === 'string' ? (cfg['magentoEndpoint'] as string) : ''
  if (!endpoint) {
    throw new Error('Magento endpoint is required for Magento provider')
  }

  const token = typeof cfg['magentoToken'] === 'string' ? (cfg['magentoToken'] as string) : undefined

  const client = createMagentoClient({
    endpoint,
    token,
  })

  return {
    async getProduct(id: string): Promise<CommerceProduct | null> {
      const variables: ProductsQueryVariables = {
        filter: null,
        search: id,
        filter1: null,
        pageSize: 1,
        currentPage: 1,
        sort: null,
      }
      const data = await client.request<ProductsQuery>(
        ProductsDocument,
        variables,
      )

      const item = data.products?.items?.[0]
      if (!item) return null

      return mapMagentoProduct(item)
    },

    async getProducts(params?: CommerceListParams): Promise<CommerceProduct[]> {
      const variables: ProductsQueryVariables = {
        filter: null,
        search: params?.search ?? null,
        filter1: null,
        pageSize: params?.pageSize ?? 20,
        currentPage: params?.page ?? 1,
        sort: null,
      }

      const data = await client.request<ProductsQuery>(
        ProductsDocument,
        variables,
      )

      const items = data.products?.items ?? []
      return items.map(mapMagentoProduct)
    },
  }
}
